# 추상 클래스보다는 인터페이스를 우선하라
## 자바가 제공하는 다중 구현 메커니즘
자바가 제공하는 다중 구현 메커니즘은 2가지다. 
+ 인터페이스
+ 추상 클래스

인터페이스와 추상 클래스를 비교해보자.
### 공통점
+ 타입을 정의하기 위한 다중 구현 메커니즘이다.
+ 인스턴스 메소드를 구현 형태로 제공한다.
> 추상 클래스와 인터페이스는 Java에서 다중 구현을 제공하기 위한 수단이다.  <br>
> 특히 Java 8부터는 default 메서드를 통해서 인터페이스에도 구현을 제공할 수 있다. <br>
또한 Java 9에서는 인터페이스에 private 메서드까지 정의할 수 있다.

<br>

인터페이스에 구현을 정의할 수 있는 시점에서 추상 클래스와 인터페이스의 `큰 차이`는 `단일 상속`과 `다중 구현`일 것이다. 
###  인터페이스
`인터페이스`가 선언한 메서드를 `모두 정의`하고 일반 규약을 지킨 클래스라면, <br> 다른 어떤 클래스를 상속했든 `같은 타입으로 취급`한다. <br>
 즉, 구현클래스가 인터페이스의 타입을 갖게된다.

### 추상 클래스
즉, `다중 상속을 지원하지 않는 Java의 특성상` `추상 클래스가 정의한 타입을 구현하는 클래스`는 반드시 `추상 클래스의 하위 클래스`가 되어야한다는 점이다. 
즉, 새로운 타입 정의에 제약이 생긴다는 의미이다.

## 인터페이스
코드와 함께 인터페이스 구현에 대해 정리해보자. <br>

### 인터페이스 장점: 손쉽게 새로운 인터페이스를 구현할 수 있다.
인터페이스로 구현하면, Person은 Walker와 Runner 타입을 얻을 수 있다. <br>
클래스 선언에 implements 구문만 추가하면 된다.
```java
// Person
package study.effectivejava.item20;

public class Person implements Walker, Runner{
    
}
```
```java
// Runner
package study.effectivejava.item20;

public interface Runner {
    default int run() {
        return 2;
    }
}
```

```java
// Walker
package study.effectivejava.item20;

public interface Walker {
    default int walk() {
        return 1;
    }
}
```

<br>

### 추상 클래스는 계층구조상 두 클래스의 공통 조상이어야 한다.
아래 예시코드처럼, 하나의 추상 클래스만 상속받을 수 있다. <br><br>
Cat은 추상 클래스인 Animal을 상속하고, 추상 메서드인 sound를 재정의했다.
```java
package study.effectivejava.item20;

public class Cat extends Animal{

    public Cat() {
        this.kind = "포유류";
    }

    @Override
    public void sound() {
        System.out.println("야옹");
    }

}
```

```java
package study.effectivejava.item20;

public abstract class Animal {

    String kind;

    abstract void sound();

}
```

## 인터페이스는 믹스인(mix) 정의에 안성맞춤이다.
믹스인이란 클래스가 구현할 수 있는 타입이다. <br> 믹스인을 구현한 클래스에 원래의 '주된 타입' 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.

### 인터페이스
 Comparable, Clonable, Serializable가 있다.  <br>
 Comparable은 자신을 구현한 클래스의 인스턴스들끼리는 순서를 정할 수 있다고 선언하는 믹스인 인터페이스다. <br><br>
 Comparable, Serializable 을 사용한 예이다.
 ```java
public class Rank implements Comparable<Rank>, Serializable {
    
    @Override
    public int compareTo(Rank o) {
        return 0;
    }
}
```

<br>

### 추상 클래스는 믹스인을 정의할 수 없다.
단일 상속만 지원하기 때문에 믹스인이 들어갈만한 자리가 없다.

## 인스터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.
예를 들어 가수(Singer) 인터페이스와 작곡가(SongWriter) 인터페이스가 있다고 해보자. <br>
```java
package study.effectivejava.item20;


public interface Singer {
    void sing(String song);
}
```

```java
package study.effectivejava.item20;

public interface SongWriter {
    void compose(int charPosition);
}
```

그리고 주변에 작곡도 하는 가수(SingerSongWriter)가 제법 있다. <br>
이 코드처럼 타입을 인터페이스로 정의하면 가수 클ㄹ스가 Singer와 SongWriter 모두를 구현해도 전혀 문제되지 않는다. <br>
Song, SongWriter 모두를 확장하고 새로운 메서드까지 추가한 제3의 인터페이스를 정의할 수도 있다.
```java
package study.effectivejava.item20;

public interface SingerSongWriter extends SongWriter, Singer {
    void actSensitive();
}
```

### 추상 클래스 경우, 조합 폭발으로 이어질 수 있다.
추상 클래스로 만들면 다중상속이 불가능해, 새로운 추상클래스를 만들어서 클래스 계층을 표현할 수 밖에 없다. <br>
게다가 복잡한 계층구조일 경우에 많은 조합이 필요하고, 고도 비만 계층으로 이어질 수 있다.

## 래퍼 클래스 관용구와 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.
타입을 추상 클래스로 정의해두면 그 타입에 기능을 추가하는 방법은 상속뿐이다. <br>
상속해서 만든 클래스는 래퍼 클래스보다 활용도가 떨어지고 깨지기는 더 쉽다.
> "래퍼클래스의 활용도가 더 높다" [item 18](https://github.com/Kim-Gyuri/studying_programming_archive/blob/main/effective%20java/4%EC%9E%A5%20%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%20%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/item%2018/%EC%83%81%EC%86%8D%EB%B3%B4%EB%8B%A4%EB%8A%94%20%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EC%9D%84%20%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC.md) 정리편을 참고하자.
> 
