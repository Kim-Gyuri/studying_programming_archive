# 타입 안전 이종 컨테이너 패턴
제네릭은 `Set<E>`, `Map<K,V>` 등의 컬레션과 `ThreadLocal<T>`, `AtomicReference<T>` 등의 단일원소 컨테이너에도 흔히 쓰인다. <br>
여기서, 매개변수화되는 대상은 (원소가 아닌) 컨테이너 자신이다. <br>
```java
// ✅ Set이 매개변수화됨
Set<Integer> numberSet = new HashSet<>();

// ✅ List가 매개변수화됨
List<Integer> numberList = new ArrayList<>();

// ✅ Map이 매개변수화됨
Map<Integer, String> idToName = new HashMap<>(); 
```
Set<Integer>에서 **제네릭이 적용된 대상은 Set**다. <br>
List<Integer>에서 **제네릭이 적용된 대상은 List**다. <br>
Map<>에서 **제네릭이 적용된 대상은 Map**이다. <br><br><br>

## 타입 안전 이종 컨테이너 패턴(type safe heterogeneous container pattern)
컨테이너 대신 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공한다. <br>
### 예: Favorites 클래스
![image](https://github.com/user-attachments/assets/27639a73-6b6c-4cfc-87b0-d0e3685033ee)  <br>
기대한 대로 "Java cafebabe Favorites"를 출력한다. <br>
"Java"는 String 타입으로 저장되었으며, <br>
0xcafebabe(16진수 정수)는 Integer 타입으로 저장되었고, <br>
Favorites.class는 Class<?> 타입으로 저장되었음을 확인할 수 있다. <br><br>

코드를 분석하면 다음과 같다. <br>

#### Map<Class<?>, Object> 사용
favorites 필드는 키를 타입(**Class<?>**)으로, 값을 Object로 저장하는 Map<>이다. <br>
이렇게 하면 다양한 타입의 객체를 저장할 수 있다.

#### 제네릭 메서드 활용
+ **putFavorite(Class<T> type, T instance)** : 타입 정보(**Class<T> type**)와 객체(T instance)를 함께 저장한다.
+ **getFavorite(Class<T> type)** : type.cast(favorites.get(type))을 사용하여 타입 안정성을 유지하며 객체를 반환한다.

#### 타입 캐스팅 없이 안전한 조회
+ **T getFavorite(Class<T> type)** 메서드는 타입을 추론하여 반환하므로, 호출 시 형변환이 필요 없다.
+ type.cast(...)를 사용하여 ClassCastException을 방지한다.

<br>

###  타입 안전 이종 컨테이너 패턴
타입 안전 이종 컨테이너 패턴은 `Map<Class<?>, Object>`를 사용하여 여러 타입의 객체를 안전하게 저장하는 방식이다. <br>
포인트는 제네릭 메서드를 활용하여 타입 정보를 함께 저장하고, 이를 통해 객체를 안전하게 반환하는 것이다. <br>

위의 코드를 보면 알 수 있듯이, 다음과 같은 장점이 있다. <br>
+ **타입 안정성(Type Safety)** : 컴파일 타임에서 타입 검사가 이루어져 런타임 오류를 방지할 수 있다.
+ **유연성(Flexibility)** : 하나의 컨테이너에서 여러 타입의 객체를 관리할 수 있다.
+ **형변환 불필요(No Explicit Casting)** : getFavorite(**Class<T> type**)을 호출할 때 형변환이 필요 없다.

> `참고` <br>
> **타입토큰** : 컴파일 타임 정보와 런타임 타입 정보를 알아내기 위해 메서드들이 주고받는 class 리터럴.

<br><br>

### ✔️ `Class<T>`는 `Class<?>`에 안전하게 들어갈 수 있다.
여기서 와일드 카드 타입으로 put 할수 없다고 생각할 수 있지만, 이때 키가 와일드 카드 타입이기 때문에 넣을 수 있다. <br>
```java
private Map<Class<?>, Object> favorites = new HashMap<>();
```
일반적으로 와일드카드(?)는 불특정한 타입을 의미하기 때문에 타입 안정성을 보장할 수 없는 경우 put이 불가능한 경우가 많다. <br>
그러나 이번 경우에는 Class<?>가 키 타입이므로 put이 가능하다. <br><br>

`Map<Class<?>, Object>`를 보면 알 수 있다. <br>
Class<?> → 임의의 클래스 타입을 의미하는 제네릭 표현이다. <br>
Object → 해당 클래스 타입과 관련된 인스턴스를 저장할 수 있다. <br>
즉, favorites는 **임의의 `Class<T>`를 키로 사용하고, 해당 타입의 인스턴스를 Object로 저장하는 구조**입니다. <br><br>

```java
public <T> void putFavorite(Class<T> type, T instance) {
    favorites.put(Objects.requireNonNull(type), instance);
}
```
type의 타입은 Class<T>이며, instance의 타입은 T다. <br>
`Class<T>는 Class<?>의 하위 타입이므로, Class<T>를 Class<?>으로 안전하게 저장할 수 있다.` <br><br>

#### 🤔 `Class<T>`는 `Class<?>`에 안전하게 들어갈 수 있는 이유
`Class<?>`는 `임의의 Class<T>`를 의미한다. <br>
`Class<T>`는 `Class<?>의 하위 타입(Class<? super T>이 아님)`이다. <br>
즉, `모든 Class<T>는 Class<?>에 안전하게 할당`할 수 있다.
> `와일드카드인 ?`는 임의의 타입을 나타내며, 정해지지 않은 unknown type으로, 타입에 제한이 없어 이를 비제한 와일드카드 타입이라고 한다.

<br><br>

#### 🚫 putFavorite(Class<?> type, T instance)로 하면 안된다.
```java
public <T> void putFavorite(Class<?> type, T instance) { // ❌ 문제 발생 가능
    favorites.put(type, instance);
}
```
type의 타입이 `Class<?>`이므로, 정확한 T의 타입을 알 수 없다. <br>
즉, T가 어떤 타입인지 알 수 없으므로, instance를 안전하게 favorites에 저장할 수 없다. <br>
컴파일러 입장에서는 `Class<?>`가 특정한 T를 보장하지 않으므로, put(type, instance); 호출이 안전하지 않다고 판단하여 오류가 발생할 수 있다. <br><br><br>

### ✔️ `Class<T>`
Java의 `Class<T>`는 제네릭 클래스로, 특정 타입 T에 대한 Class 객체를 나타낸다. <br>
즉, `Class<T>`는 해당 타입에 대한 메타정보(클래스 정보)를 담고 있으며, 런타임에서 타입 변환을 안전하게 수행할 수 있도록 돕는다. <br>
```java
public final class Class<T> {
    T cast(Object obj);
}
```
이 구조에서 cast 메서드는 주어진 Object가 타입 T와 호환되는지 확인한 후 변환하는 역할을 한다. <br><br>

cast(Object obj)의 동작 방식은 다음과 같다. <br>
+ cast(Object obj)는 런타임에서 타입 안정성을 보장하며, obj가 T 타입으로 변환 가능할 경우 반환한다.
+ 변환이 불가능한 경우 ClassCastException을 던집니다.

<br><br>

Favorites 클래스의 getFavorite()를 다시 보자! <br>
```java
    public <T> T getFavorite(Class<T> type) {
        return type.cast(favorites.get(type));
    }
```
getFavorite 구현은 Class cast 메서드를 사용해 이 객체 참조를 Class 객체가 가리키는 타입으로 동적 형변환한다. <br><br><br>

#### 👌 cast()를 이용한 안전한 형변환
String.class.cast(obj)는 obj가 String일 경우 변환을 수행하고, 그렇지 않으면 예외를 던진다. <br>
![image](https://github.com/user-attachments/assets/b448c83e-dc70-4e22-ac7e-ec7330bdc0c7) <br><br>
 
#### 🚫 cast()가 실패하는 경우
obj가 Integer가 아니므로 ClassCastException이 발생한다. <br>
![image](https://github.com/user-attachments/assets/b1e55a2c-e1d3-480d-ab51-beab44a5567f)

# 타입 안전 이종 컨테이너의 제약
악의적인 클라이언트가 Class 객체를 (제네릭이 아닌) 로타입으로 넘기면 Favorites 인스턴스의 타입 안정성이 쉽게 깨진다. <br>
![image](https://github.com/user-attachments/assets/0fb92327-9f3f-43af-92cd-55f7343a18e9) <br>
![image](https://github.com/user-attachments/assets/241e151a-9740-4bb0-b919-88c3c49d59e3) <br>
