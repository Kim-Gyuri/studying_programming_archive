# 📌 상속
+ 부모 생성자 호출
+ 자동 타입 변환
+ 메소드 재정의
+ 필드의 다형성
+ 강제 타입 변환
+ 상속관계에서 객체생성 방법

> `포인트`
```
# 부모 =  자식 (자동으로 형변환) 
자동 형변환은 object casting이라고도 한다.
big = small (upcasting)


# (자식) 부모.method(); (강제 형변환)
downcasting
````

## 부모 생성자 호출
자바에서도 자식 객체를 생성하면, 부모 객체가 먼저 생성되고 그다음에 자식 객체가 생성된다.  <br>

### 이것을 메모리로 표현하면 다음과 같다. <br>
![다운로드](https://user-images.githubusercontent.com/57389368/208690448-de8fde42-0d84-4233-b26c-89e17e6c64e1.png) <br>

### 모든 객체는 클래스의 생성자를 호출해야만 생성된다.
- 자식 객체를 생성하려면 클래스의 생성자를 호출해야 한다.
- 부모 생성자는 자식 생성자의 맨 첫 줄 super();에서 호출된다.
- (명시적으로 선언되지 않아도) 컴파일러에 의해 기본 생성자가 만들어지므로 문제없이 실행된다.
- super()는 부모의 기본 생성자를 호출한다.

## 자동 타입 변환
다형성을 구현하려면 메소드 재정의와 타입변환이 필요한다. <br>
- 자동 타입 변환 `부모타입 = 자식타입;`
- 자식은 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급될 수 있다. 
- 자동 타입 변환된 후, 부모 클래스에 선언된 필드/메소드만 접근이 가능하다.
- 예외, 메소드가 자식 클래스에서 재정의되었다면 자식클래스의 메소드가 대신 호출된다. 

## 메소드 재정의
> Override(재정의) : 상속관계에서 상속받은 하위 클래스가 상위 클래스의 동작을 수정하는 것

```
Animal d = new Dog();
d.eat(); -> 실행시점에 사용될 메소드가 결정된다.
```

<br> <br>

+ `오버라이드를 통해 하위 클래스를 접근할 수 있다.`
> Override(재정의 = 부모 메서드 무시) <br>
> 메모리에 부모와 자식 메서드가 공존하지만, 결국 자식 메서드가 실행된다. <br>

<br>

+ override(재정의): 동적 바인딩
> 호출될 메소드가 실행시점에서 결정되는 바인딩을 말한다 <br>
> 프로그램 속도가 느려지는 원인이 된다. <br>

## 필드의 다형성
`왜 자동 타입 변환이 필요할까?` <br>
- 필드의 타입을 부모 타입으로 선언하면 다양한 자식객체들이 저장될 수 있기 때문이다.
- 객체지향 프로그래밍, 객체들은 다른 객체로 교체될 수 있어야 한다.

## 강제 타입 변환
- 부모 타입을 자식 타입으로 변환하는 것 `자식 = (자식) 부모타입;`
- 단, 자식 타입이 부모 타입으로 자동 타입 변환한 후 다시 자식 타입으로 변환하는 경우에 해당된다.

## 상속관계에서 객체생성 방법
- 간접  `Animal d = new Dog();`
- 직접  `Dog d = new Dog();`     

#### 부모 클래스를 이용하지 않는 방식
- 직접 생성한다.
> Dog d = new Dog(); <br>
> d는 Animal, Dog 모두 접근 가능하다. <br>

#### 부모 클래스를 이용하는 방식
- 하위 클래스의 동작 방식을 모를 때, 간접이용.
- class(실행) 파일만 있고, java(소스코드) 파일이 없는 경우
> Animal d = new Dog(); <br>
> d는 하위 클래스 Dog에 접근할 수 없다. -> ( Override 재정의를 한 경우는 접근가능!) <br>

