`프로세스` <br> 메모리를 할당받아 실행 중인 애플리케이션을 말한다. <br>

`멀티 프로세스` <br> 하나의 애플리케을 2개 실행시킨다.  <br> (예:) 2개의 메모장(프로세스)을 킨다. <br> 

`스레드` <br> 
+ 운영체제는 두 가지 이상의 작업을 동시에 처리하는 멀티 태스킹을 할 수 있도록 CPU 및 메모리 자원을 프로세스마다 적절히 할당해주고, 병렬로 실행시킵니다.
+ (멀티 태스킹 예시) 워드로 문서작업 하면서 윈도우 미디어 플레이어로 음악을 듣는다.
+ (멀티 스레드 예시) 메신저: 채팅기능 + 파일전송기능

`멀티 스레드` <br>
+ 하나의 프로세스 내부에 생성되기 때문에 하나의 스레드가 예외를 발생시키면 프로세스 자체가 종료될 수 있다. 
+ (다른 스레드에 영향 미친다.)
+ 예: 메신저의 파일전송기능이 고장나면 메신저 프로세스 자체가 종료될 수 있다. (파일전송 스레드 예외발생--> 채팅 스레드도 종료됨)
+ 다양한 곳에 쓰인다. <br> 1. 대용량 데이터의 처리 시간을 줄이기 위해 데이터를 분할해서 병렬로 처리하기도 한다. <br> 2. UI를 가지고 있는 애플리케이션에서 네트워크 통신을 하기 위해 사용된다.
<br> 3. 다수 클라이언트의 요청을 처리하는 서버를 개발할 때 사용된다.
> 멀티 프로세스 : 각각의 프로세스가 독립적이여서 다른 프로세스에 영향을 미치지 않는다. <br> 멀티 프로세스인 워드와 엑셀을 동시에 사용하던 도중, 워드에 오류가 생겨도 엑셀은 정상동작된다.


<br><br>

## 메인 스레드
+ 자바의 모든 애플리케이션은 메인 스레드가 main()메소드를 실행하면서 시작한다.
+ 메인 스레드는 main() 메소드의 첫 코드부터 아래로 순차적으로 실행하고, main() 메소드의 마지막 코드를 실행하거나 return문을 만나면 실행종료된다.
```java
public static void main(String[] args) {
  String data = null;
  if (..) { .. }
  while(..) { ..}
  System.out.println("..");
}
```

![메인스레드](https://user-images.githubusercontent.com/57389368/186592603-81f44860-9048-4501-a1eb-09b2194c0192.JPG) <br>
+ 메인 스레드는 작업 스레드를 만들어 병렬로 코드를 실행할 수 있다. 
+ 즉, 멀티 스레드를 생성해서 멀티 태스킹을 수행한다.
+ 멀티 스레드 애플리케이션을 보면, 메인 스레드가 작업 스레드1을 생성하고 실행하고 다음 작업 스레드를 실행한다. 
+ 멀티 스레드 애플리케이션의 경우, 실행 중인 스레드가 남아 있다면 프로세스는 종료되지 않는다.
+ 싱글 스레드 애플리케이션의 경우, 메인스레드가 종료하면 프로세스도 종료된다.

## 작업 스레드 생성과 실행
`멀티 스레드로 실행하는 애플리케이션` <br> 메인 스레드 + 추가적 병렬 작업 스레드를 생성한다.
> `자바에서는 작업 스레드도 객체로 생성되기 때문에 클래스가 필요하다.` <br> java.lang.Thread 클래스를 직접 객체화해서 생성해도 되지만, <br> `Thread 클래스를 상속해서 하위 클래스를 만들어 생성할 수 도 있다.`

### Thread 클래스로부터 직접 생성
```java Thread thread = new Thread(Runnable target); ``` <br>
java.lang.Thread 클래스부터 작업 스레드 객체를 직접 생성하려면 다음과 같이 Runnable을 매개값으로 갖는 생성자를 호출해야 한다.
+ Runnable은 작업 스레드가 실행할 수 있는 코드를 가지고 있는 객체라고 해서 붙여진 이름이다.
+ Runnable은 인터페이스 타입이기 때문에 구현 객체를 만들어 대입해야 한다.
+ Runnable에는 run()메소드 하나가 정의되어 있는데, 구현 클래스는 run()을 재정의해서 작업 스레드가 실행할 코드를 작성해야 한다.

`Runnable 구현 클래스` <br>
```java
class Task implements Runnable {
  public void run() {
      스레드가 실행할 코드;
  }
}
```

`Runnable 구현 객체를 생성한 후, 이것을 매개값으로 해서 Thread 생성자를 호출해야 비로소 작업 스레드가 생성된다.` <br>
```java
Runnable task = new Task();
Thread thread = new Thread(task);
```

> Runnable은 작업 내용을 가진 객체이지 실제 스레드가 아니다.

`Thread 생성자를 호출할 때 Runnable 익명 객체를 매개값으로 사용할 수 있다.` <br> 코드를 좀 더 절약해서, 오히려 이 방법이 좋다. <br>
```java
Thread thread = new Thread(new Runnable() {
  public void run() {
      스레드가 실행할 코드;
  }
});
```

`작업 스레드는 start() 메소드를 호출해야만 실행된다.` <br> 작업 스레드는 매개값으로 받은 Runnable의 run()메소드를 실행하면서 자신의 작업을 처리한다. <br>
```java
thread.start();
```

<br><br>

### 메인 스레드만 이용한 경우 - 예제
`가정조건` <br>
+ 0.5초 주기로 비프 음을 발생시키면서 동시에 출력하는 작업이 있다고 가정하자.
+ 비프음 발생과 출력은 서로 다른 작업이므로 메인 스레드가 동시에 두 가지 작업을 처리할 수 없다.

```java
public class Main {
    public static void main(String[] args) {
        Toolkit toolkit = Toolkit.getDefaultToolkit(); //Toolkit 객체 얻기
        for (int i=0; i<5; i++) {
            toolkit.beep(); //비프음 발생
            try {
                Thread.sleep(500); //0.5초간 일시정시
            } catch (Exception e) {

            }
        }
        for (int i=0; i<5; i++) {
            System.out.println("띵");
            try {
                Thread.sleep(500);
            } catch (Exception e) {

            }
        }

    }
}
```

+ 메인 스레드는 비프음을 모두 발생한 다음, 출력을 시작한다. 

### 메인 스레드와 작업 스레드가 동시에 실행 - 예제
+ 비프음을 발생시키면서 동시에 출력을 하려면 두 작업 중 하나를 메인 스레드가 아닌 다른 스레드에서 실행해야 한다.
+ 출력은 메인 스레드가 담당하고 비프음을 들려주는 것은 작업 스레드가 담당하도록 수정해보자.

`Runnable 구현 클래스` <br>
```java
import java.awt.*;

public class BeepTask implements Runnable {
    @Override
    public void run() {
        Toolkit toolkit = Toolkit.getDefaultToolkit(); //스레드 실행내용
        for (int i=0; i<5; i++) {
            toolkit.beep();
            try {
                Thread.sleep(500);
            } catch (Exception e) {

            }
        }
    }
}
```

`실행문` <br>
```java
public class Main {
    public static void main(String[] args) {
        Runnable beepTask = new BeepTask();
        Thread thread = new Thread(beepTask); //작업 스레드 생성
        thread.start();                       //작업 스레드 실행

        for (int i=0; i<5; i++) {    //동시에 메인 스레드의 for()문을 실행시킨다.
            System.out.println("띵");
        }
        try{
            Thread.sleep(500);
        } catch (Exception e) {

        }
    }
}
```


### 메인 스레드와 작업 스레드가 동시에 실행 - 응용: 익명 구현 객체로 작업 스레드 생성
구현 클래스 없이, 익명 구현 객체로 대체하여 작업 스레드를 만들 수 있다.
```java
import java.awt.*;

public class Main {
    public static void main(String[] args) {

        Thread thread = new Thread(new Runnable() { //작업 스레드 만들기
            @Override
            public void run() {
                Toolkit toolkit = Toolkit.getDefaultToolkit();
                for (int i=0; i<5; i++) {
                    toolkit.beep();
                    try {
                        Thread.sleep(500);
                    } catch (Exception e) {

                    }
                }
            }
        });
        thread.start();

        for (int i=0; i<5; i++) {
            System.out.println("띵");
        }
        try{
            Thread.sleep(500);
        } catch (Exception e) {

        }
    }
}
```


