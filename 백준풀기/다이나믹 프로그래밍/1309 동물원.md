[1309 동물원](https://www.acmicpc.net/problem/1309)

### 문제
사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하여라. <br>
+ 어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있다. (2*N 배열크기)
+ 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다. 

<br>

### 풀이
+ dp[][] 정의
```
dp[i번째 줄에 놓는다.][무리에 두는 경우의 수]

(행) 
1번 ~ n번째 줄까지 놓는 방법을 찾으니까 dp[n+1][]

(열)
무리에 두는 경우의 수는 다음과 같다.
-> i번째 줄에 사자가 없어도 되는 경우
-> i번째 줄에 "1번째 칸에" 사자가 있을 경우
-> i번째 줄에 "2번째 칸에" 사자가 있을 경우
그래서 dp[][3]이 된다.
```

+ 초기값 정의
```
사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.
-> 1로 초기화해준다.

D[1][0]=D[1][1]=D[1][2]=1
```

+ 점화식 세우기
```
# i번째 줄에 사자가 없어도 되는 경우
조건을 만족하기 위해서는,
i-1줄에 사자가 없어야 한다  ("2줄 연속 사자가 없는 경우")
(또는) i-1줄에 1번째 칸에 사자가 있는 경우  ("1번째 줄이 텅비고, 2번째 줄에 1마리를 배치하는 경우")
(또는) i-1줄에 2번째 칸에 사자가 있을 경우  ("1번째 줄이 텅비고, 2번째 줄에 1마리를 배치하는 경우")
dp[i][0] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2])



#i번째 줄에 "1번째 칸에" 사자가 있을 경우
i-1줄에 사자가 없어야 한다  (1번째 줄이 텅비고, 2번째 줄에 1마리를 배치하는 경우")
(또는) i-1줄에 2번째 칸에 사자가 있을 경우  ("대각선으로 배치하는 경우")
dp[i][1] = (dp[i-1][0] + dp[i-1][2])



#i번째 줄에 "2번째 칸에" 사자가 있을 경우
i-1줄에 사자가 없어야 한다  (1번째 줄이 텅비고, 2번째 줄에 1마리를 배치하는 경우")
(또는) i-1줄에 1번째 칸에 사자가 있을 경우  ("대각선으로 배치하는 경우")
dp[i][2] = (dp[i-1][0] + dp[i-1][1])
```
> [참고](https://velog.io/@kimmjieun/%EB%B0%B1%EC%A4%80-1309%EB%B2%88-%EB%8F%99%EB%AC%BC%EC%9B%90-Java-%EC%9E%90%EB%B0%94)

<br>

###  코드
> 주석에 설명을 달았다.
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    static int[][] dp; // dp 탐색용 배열
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine()); // 동물원 우리 크기 2*n

        System.out.println(solution(n));
    }

    private static int solution(int n) {
        // 배열 초기화
        // (행) :1번 ~ n번째 줄까지 놓는 방법을 찾으니까 dp[n+1][]
        // (열) :무리에 두는 경우의 수는 다음과 같다. (두지 않는다. 1번째 칸에, 2번째 칸에)
        dp = new int[n+1][3];

        // 초기값
        // 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 했으니까
        // 1번째 줄에 (해당 경우의 수에 대해) 1로 초기화
        for (int i=0; i<3; i++) {
            dp[1][i] = 1;
        }

        // DP 탐색 ---
        for (int i=2; i<=n; i++) {
            // i번째 줄에 사자가 없어도 되는 경우
            dp[i][0] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2]) % 9901;
            //  i번째 줄에 "1번째 칸에" 사자가 있을 경우
            dp[i][1] = (dp[i-1][0] + dp[i-1][2]) % 9901;
            //  i번째 줄에 "2번째 칸에" 사자가 있을 경우
            dp[i][2] = (dp[i-1][0] + dp[i-1][1]) % 9901;
        }
        // 배치하는 경우의 수를 9901로 나눈 나머지를 출력한다.
        return (dp[n][0] + dp[n][1] + dp[n][2]) % 9901;
    }
}
```
