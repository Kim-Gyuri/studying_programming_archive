[10844 쉬운 계단 수](https://www.acmicpc.net/problem/10844)

### 문제
길이가 N인 계단 수가 총 몇 개 있는지 구하고,  1,000,000,000으로 나눈 나머지를 출력한다. <br>
+ 계단수: 모든 자리의 차이가 1이 된다. 
+ 0으로 시작하는 수는 계단수가 아니다.
> ex: 45656

<br>

### 풀이
+ DP 탐색용 배열을 만든다.
```
1. dp[자릿수][오는 숫자] = 경우의 수;
    자릿수는 1~N이 되므로, N+1 크기로 초기화
    오는 숫자는 0~9가 해당되므로, 10 크기로 초기화
-> dp[1][i] = 1; 
     자릿수 1인 경우는 "한자리 수" 이므로, 
     i에는 1~9가 온다. (0으로 시작하는 수는 없다고 했으니)
     dp[1][1] = "자릿수 1이면서 1이 오는 계단은 "1" 뿐이다. -> 1;
```

+ 자릿수가 1인 경우 dp[1][i] = 1로 초기화 시킨다.

+ 자릿수가 2 이상인 경우, 아래와 같은 경우의 수를 탐색해야 한다.
```
# 숫자가 9가 오는 경우
앞자리와 차이가 1이어야 한다. 89밖에 없다.


# 숫자가 0이 오는 경우
앞자리와 차이가 1이어야 하고, 앞자리에는 0이 올 수 없다. 10밖에 없다.



# 나머지 경우 ( 경우의 수가 2개가 되는 경우)
다음과 같은 점화식이 생긴다.
1) 2자리를 만드는 경우, 끝자리가 4로 오는 경우의 수는(DP[2][4]) 34, 54 2개 이다.
2) 2자리를 만드는 경우, 끝자리가 6으로 오는 경우의 수는(DP[2][6]) 56,76 2개이다.
3) 3자리를 만드는 경우, 끝자리가 5로 오는 경우의 수는(DP[3][5]) DP[2][4] + DP[2][6]가 된다.
-->  이를 점화식으로 DP[i][j] = DP[i-1][j-1] + DP[i-1][j+1] 이 된다.
```

+ 마지막에, 모든 경우의 수를 다 더해주면 "길이가 N인 계단 수가 총 몇 개인지" 결과가 나온다.
> [참고](https://yabmoons.tistory.com/22)

<br>

### 코드
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    static long answer = 0; // 결과값, 정답을 1,000,000,000으로 나눈 나머지
    static long[][] dp; // dp탐색용 배열, 값(구할 수 있는 계단에 대한 경우의 수)을 넣는다.
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine()); // 입력, 계단 길이 N

        // 배열크기 초기화
        // [계단 자릿수][들어오는 숫자] = 경우의 수를 정의하기 위해,
        // 자릿수는 N+1이 되고, (0~9) 숫자가 들어오니 10이 된다.
       dp = new long[n+1][10];

       // 초기화
       // 자릿수 N=1인 경우, 1~9가 들어올 수 있는 숫자다.
       // 한자리 수 이므로 경우의 수는 각각 1이 된다.
       for (int i=1; i<10; i++) {
           dp[1][i] = 1;
       }

       // DP 탐색 --
       for (int i=2; i<=n; i++) {
           for (int j=0; j<10; j++) {
               // 숫자가 9인 경우, 앞자리와 차이가 1이어야 한다. 89밖에 없다.
               if (j== 9) {
                   dp[i][j] = dp[i-1][j-1] % 1000000000;
               }
               // 숫자가 0인 경우, 앞자리와 차이가 1이어야 한다. 10밖에 없다.
               else if (j == 0) {
                   dp[i][j] = dp[i-1][j+1] % 1000000000;
               }
               // 올수 있는 경우의 수가 2가지 인 경우,
               // 1) 2자리를 만드는 경우, 끝자리가 4로 오는 경우의 수는(DP[2][4]) 34, 54 2개 이다.

               // 2) 2자리를 만드는 경우, 끝자리가 6으로 오는 경우의 수는(DP[2][6]) 56,76 2개이다.

               // 3) 3자리를 만드는 경우, 끝자리가 5로 오는 경우의 수는(DP[3][5]) DP[2][4] + DP[2][6]가 된다.
               // -> 이를 점화식으로 DP[i][j] = DP[i-1][j-1] + DP[i-1][j+1] 이 된다.
               else {
                   dp[i][j] = (dp[i-1][j-1] + dp[i-1][j+1]) % 1000000000;
               }
           }
       }

       // 마지막에, 모든 경우의 수를 다 더해주면 "길이가 N인 계단 수가 총 몇 개인지" 결과가 나온다.
       for (int i=0; i<10; i++) {
           answer += dp[n][i];
       }
       // 여기에 1,000,000,000으로 나눈 나머지를 출력한다
        System.out.println(answer % 1000000000);
    }
}
```
 
