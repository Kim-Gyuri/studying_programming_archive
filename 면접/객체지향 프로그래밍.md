# 📌 개발상식
+ 좋은 코드란?
+ 객체지향 프로그래밍이란?
+ 객체지향 설계원칙은 무엇인가?


## 좋은 코드란?
인터넷을 검색해보면 아래 조건을 많이 볼 수 있다.
+ 읽기 쉬운 코드
+ 중복이 없는 코드
+ 테스트가 용이한 코드

#### 결론, 상황에 따라 트레이드 오프를 고민하여 코드를 관리해나가는 것
코드 간의 의존성을 고민해보고, 적절하게 확장 가능한 구조로 설계가 가능한지? 고민해봐야 한다.


## 객체 지향 프로그래밍이란?
객체지향의 핵심은 다형성이다.  <br>
+ 다형성 : 유연하고, 변경이 용이하다. 
+ "역할(인터페이스)과 구현(인터페이스 구현체)을 분리한 것",  
+ 요구사항이 변경되어도 새로운 구현체를 만들어 교체가능한 설계가 되는지?

<Br>
  
`예시` <br>
```
로미오와 줄리엣 공연을 기획한다고 했을 때, 
          로미오역 배우섭외는 A,B,C 배우 누구든 대체가 가능하다. (대체 가능성)
          로미오역 배우는 줄리엣 역할 연기를 몰라도 공연은 진행된다. 
 ```
> A 배우는 구현체 대상 자체 변경(공연 캐릭터 변경)이 있어도 영향을 받지 않는다. 

<br>
  
#### 다형성만으로는 구현 객체를 변경할 때 클라이언트 코드가 변해버린다.
다형성만으로 객체지향설계를 지키기 어렵다. <br> 다형성만으로는 OCP, DIP를 지킬 수 없다.
+ OCP 위반: 변경하려다 보니까 클라이언트가 코드를 직접 변경해야 한다. (변경에 닫혀 있지 않다.)
+ DIP 위반: 클라이언트가 구현체에 의존한다.

#### 관심사 분리
+ DIP 지키기 : Appconfig(공연 기획자)가 배역에 맞는 배우를 섭외하고, 공연 구성을 기획하고 책임지도록 한다.
+ OCP 지키기 : 공연기획변경요구를 받았을 때, 배우가 아닌 Appconfig(공연 기획자)가 기획을 수정한다.
  
 <br>
  
## 객체지향 설계원칙은 무엇인가?  
### 이때 객체지향 설계원칙 SOLID가 있다.
좋은 객체 지향 설계의 5가지 원칙
> SOLID는 클린코드로 유명한 로버트 마틴의 "좋은 객체지향 설계의 5가지 원칙"을 정리한 것이다.

#### SRP = 단일 책임 원칙 
SRP(Single Responsibility Principle)
+ 한 클래스는 하나의 책임만 가져야 한다.
+ (객체의 생성과 사용을 분리하여) 계층이 적절하게 나누어진 설계는, 새로운 업데이트가 있어도 해당 책임부분만 수정하면 된다.

<br>
  
#### OCP = 개방-폐쇄 원칙
`가장 중요한 원칙`  OCP(Open-Closed Principle) 
+ 소프트웨어는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
+ 자바의 다형성을 지킨다 : 새로운 업데이트를 적용하기 위해, 해당 인터페이스에 새로운 구현체를 만들어 구현한다. (기존코드 변경없이 교체식으로)
+ 기존코드에 변경이 없어야 한다: 설정자 코드를 만들어 "객체 생성과 연관관계"를 연결해주는 DI를 처리한다.

<br>
  
#### LSP = 리스코프 치환 원칙
+ 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
> 예: 자동차 구현체에 대한 하위 클래스 "악셀"이 있다고 했을 때, <br>
> "악셀: 누르면 앞으로 나간다" 규약을 어기지 않게 만들어야 한다. (느리더라도 앞으로 가도록)

 <br>
  
#### ISP = 인터페이스 분리 법칙
+ 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
> 예: 자동차 인터페이스 내부에 "운전 인터페이스" "정비 인터페이스"가 있을 때, 2개의 인터페이스로 분리하는게 낫다. <br>
     -> 정비 기능문제 업데이트 과정에서, 정비 인터페이스만 수정하면 된다. <br>
     -> 분리해서 사용하면, 운전 인터페이스에 영향없다. <br>
     -> 인터페이스가 명확해지고 대체 가능성이 높아진다. <br>

  <br><br>

 `OCP, DIP가 중요하다.` <br>
> DIP 의존관계 역전 원칙 <br>
>  프로그래머는 추상화에 의존해야 한다. 구체화에 의존하면 안 된다. <br>
> 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 한다.
