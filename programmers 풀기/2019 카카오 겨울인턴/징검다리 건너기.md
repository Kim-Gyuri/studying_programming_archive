### 문제
[징검다리 건너기](https://school.programmers.co.kr/learn/courses/30/lessons/64062)를 풀자. <br>
최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 구현해야 한다. <br>
+ 징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.
+ 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.
+ 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.
+  한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.

<br>

`입력` <br>
+ 디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones
+ 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k

<br>

`제한사항` <br>
+ stones 배열의 크기는 1 이상 200,000 이하입니다.


<br><br>

### 풀이 포인트
```
# 예시
int[] stones = {2,4,5,3,2,1,4,2,5,1};
int k = 3;
        
##  배열의 최댓값과 최솟값을 기준으로 탐색한다.
시작할 때, 
최댓값 :5
최소값 :1 


## 이진탐색( n-1 번째 니니즈가 건넌다는 기준으로)
중간값 mid :3 (5+1/2로 계산해준다.)

mid에서 모두 건널 수 있는지 ? 판단한다.
-> 1 2 는 가능
-> 3 ~ 5 값을 탐색해주면 된다.


## n-1를 건넜을 때 k를 체크해준다.
N-1번 니니즈까지 길을 건넜다고 가정하고 N번째 니니즈가 길을 건너는 차례라고 생각한다.
( K번 이내의 거리에 N이상의 값이 존재해야 길을 건널 수 있기 때문에)
연속적으로 k개 이상 나온 경우 -> 범위를 줄여주고 다시 탐색 (n번 걸을 수 없다.) 
연속 값이 k보다 작은 경우     -> 값을 늘려 다시 탐색
```

> 정리하자면

```
# 1:  해당 인원이 건널 수 있는지 탐색한다.
for () {
해당 인원이 건널 수 있다 
-> " 중간 값보다 작은 값들이므로 건널 수 있다."
->  중간 값보다 큰 인원으로 건널 수 있는지 확인한다.


해당 인원이 건널 수 없다.
-> "중간 값보다 큰 수로는 모두 건널 수 없다."
-> 중간 값보다 적은 인원으로 건널 수 있는지 확인한다.            
}



# 2:  n-1를 건넜을 때 K를 체크해준다.
if (건너뛴 수가 k개 이상인 경우) : 범위를 줄이고 다시 탐색
if (건너뛴 수가 k개보다 작은 경우): 범위를 늘려 다시 탐색
```

<br><br>

### 코드
```java

import java.util.*;

class Solution {
    static int STONE_MIN = 1; // 징검다리를 건너야 하는 최소 인원
    static int STONE_MAX = 200000000; // 징검다리를 건너야 할 최대 인원                               

    public static int solution(int[] stones, int k) {
        int min = STONE_MIN;
        int max = STONE_MAX;

       // 징검다리는 건널 수 있는 인원수를 탐색한다.
        while (min <= max) {
           // mid : 징검다리를 건너야 하는 인원
            int mid = (min + max) / 2;
           // jump : 못 건너는 징검다리의 개수
            int jump = 0;

          //-- (1) 징검다리를 건널 수 있는지 탐색한다.
            for (int i=0; i<stones.length; i++) {
               // "디딤돌의 숫자 - 건너는 친구의 수" < 0 인 경우
                if (stones[i] - mid <= 0) jump++; // 0보다 작으니 건널 수 없다.
                 // 0 이상이면 "건널 수 있다"를 뜻하므로 다시 0으로 갱신한다.
                else jump = 0; 

               // 못 건너는 징검다리 수가 최대 K칸을 넘으면, "해당 값은 건널 수 없다"를 뜻함
                if (jump == k) break;
            }
            //--
         

          //-- (2)  " n-1를 건넜을 때 K를 체크해준다."  
         // 다리를 건널 수 없다면, 친구 수를 좁힌다.
            if (jump == k) max = mid - 1;
         // 징검다리를 건날 수 있다면, 더 많은 친구들이 가능한지 친구 수를 넓힌다.
            else min = mid + 1;
         //--
        }
        return min;
    }
}
```
