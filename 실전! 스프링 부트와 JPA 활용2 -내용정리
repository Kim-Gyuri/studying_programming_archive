학습 목표 : API 개발과 성능 최적화 

1. 연관관계 유무차이
 엔티티A와 엔티티B가 연관관계를 가진 경우 -> 비즈니스 로직상 연관관계가 필요하고 fetch join을 통한 성능 최적화를 누린다.
 엔티티A와 엔티티B가 연관관계를 꼭 가지고 있을 필요가 없는 경우 -> 단순히 id만 가지고 있어도 좋다.

*연관관계  o -> @JoinColumn
*연관관계  x -> @Column






2. 호출하지 않았느데 totalPrice까지 json형식으로 postman을 확인할 수 있었는가?
Q:
totalPrice 값이 나오는데 이 메소드는 언제 호출이 된건가요? 따로 호출해 준적이없는거 같습니다

A:
객체를 JSON으로 반환 시 자동으로 해당 객체의 getXX 프로퍼티를 호출하는 것을 확인 하실 수 있습니다.
->네 특별한 설정한 것 없이 테스트해봤는데 반환하는것으로 보아 내부에서 Jackson 라이브러리가 동작한 것으로 보입니다.
https://mommoo.tistory.com/83






3. 지연로딩과 프록시
예시 : 
'Order -> Member' 엔티티관계를 지연 로딩으로 설정했다.
 Order를 조회하면 Order과 연관된 Member 프록시가 함께 조회된다.
 이때 Member 프록시 객체가 아직 초기화 되지 않았다면,
 프록시 객체를 초기화해서 데이터를 로딩한 다음에 해당 데이터를 반환하는 것이 아니라 null로 반환한다는 뜻입니다.









4. API 개발과 성능 최적화 
실무에서는 엔티티 자체를 외부에 API 응답 값으로 사용하지 않고, 
HTTP API에서 서로 약속한 스펙에 맞춘 별도의 DTO라는 객체를 만들어서 반환합니다. 






5. @JsonIgnore와 프록시 관계성
하이버네이트가 Lazy 로딩을 사용하면, 해당 객체는 하이버네이트만 이해하는 프록시 객체로 로딩이 됩니다. 따라서 JSON을 만들어주는 Jackson라이브러리 입장에서는 뭔지 이해가 안되는 것이지요^^



<2 편>
6.  영속성 컨텍스트 관련
Controller : api 요청/반환 관리, requestForm. responseForm 변형 관리
Service : 비즈니스 로직 관리, Repository 접근 관리
Repository : DB 접근 관리 
 ..... - OSIV와 성능 최적화 부분

[
스프링과 JPA를 함께 사용하면, JPA가 영속성 컨텍스트를 관리해줍니다.

기본 동작은 트랜잭션이 시작할 때 영속성 컨텍스트가 생성되고, 트랜잭션이 종료될 때 영속성 컨텍스트도 함께 종료됩니다.

스프링이 이런 부분을 관리해주기 때문에 걱정하지 않으셔도 됩니다.

추가로 JPA는 트랜잭션 없이 읽기는 기능도 제공합니다. 이름 그대로 트랜잭션이 없어도 단순한 읽기는 가능합니다. 이 경우 영속성 컨텍스트는 데이터를 조회하자 마자 사라진다고 이해하시면 됩니다.

이런 메커니즘에 더해서 추가로 영향을 주는 것이 OSIV(OEIV)라는 것이 있는데요. 아마도 궁금해 하시는 부분이 바로 이것 때문에 그럴꺼에요^^ OSIV(OEIV)는 Open Session(EntityManager) In View라는 뜻인데요. 이게 마지막 퍼즐조각입니다.

스프링 부트는 기본으로 OSIV(OEIV)라는 것을 활성화시켜 두는데요. 이게 활성화 되어 있으면 API 호출 시작부터 ~ API 호출 종료까지 영속성 컨텍스트가 유지됩니다. 그래서 트랜잭션이 없는 컨트롤러에서도 지연로딩을 사용할 수 있는 것이지요. 이렇게 보면 그냥 좋아보이지만, 성능 관점에서 안좋은 포인트들이 많습니다. (그래서 안티 패턴으로 불리기도 합니다.)
]







<3 편>
7. 연관관계 질문
-------------------------------------------------------------------
*(예시 문)
: 컬렉션에 @ManyToOne을 사용할 수는 없으므로 @OneToMany을 사용해야 한다.
public class Team {

  @ManyToOne
  List<Member> members = new ArrayList<>();  
}

* (예시) 설명
예를 들어서, A,B 엔티티가 다음과 같이 있다면, 
->외래키는 B에 있고, B가 연관관계의 주인이다.
A{
  @OneToOne B b
}
Q-1 :만약 b의 결과가 없다면 어떻게 노출되어야 할까?
바로 결과는 null이 되어야 한다.

Q-2 :만약 'Q-1'에서 프록시를 적용하기 위해서 b가 프록시 객체가 된다면 어떻게 되냐?
b는 null이 아니라 프록시 객체를 가지게 됩니다.

Q-3 :결국 프록시를 미리 넣게 되면 어떻게 되냐?
null이라는 것을 넣을 수 없는 문제가 발생한다.

*1 
@OneToOne에서 외래키가 A에 있으면 A를 조회하는 순간 B의 데이터가 있는지 확인가능하다.
그래서 null을 입력해야 할지, 아니면 프록시를 입력해야 할지 명확한 판단이 가능하다.

*2
그런데 지금처럼 @OneToOne에서 외래키가 B에 있으면 A를 조회할 때 B가 데이터가 있는지 없는지 판단이 불가능하다.
그래서 null을 입력할지 아니면 프록시를 입력해야 할지 판단히 불가능합니다.

*3
따라서 이 경우 강제로 즉시 로딩을 해서 데이터가 있으면 해당 데이터를 넣고, 없으면 null을 입력하게 됩니다.


*4
컬렉션의 경우,
컬렉션은 null일 필요가 없다.
컬렉션 자체가 데이터가 없는 Empty를 표현할 수 있습니다.
따라서 컬렉션은 항상 지연로딩으로 동작할 수 있습니다.

-------------------------------------------------------------------
















8. onetoone에서 lazy관련
------------------------------------------------------------------------
(예시) : 'table 구조'
*member - phone  "OneToOne 관계일 경우"
*fk는 phone에 member_id로 존재하는 형태
*member에 phone_id를 가질 수 없다.
*(문제점:  위 테이블 구조일때 jpa입장에서 onetoone에서는 proxy객체를 생성할 수 없기때문에 lazy로 설정해도 쿼리가 나간다)


onetoone에서 lazy관련 문제를 해결하는 방법 : 2가지
구글에 hibernate onetoone nullable 같은 키워드로 검색해보시면 여러가지 시도와 결과가 있다.
그런데 깔끔한 방법이 사실 없습니다.
방법 : 구조를 바꾸어서 해결하는 방법, 구조를 유지한채 해결하는 방법

*참고
LAZY여도 객체를 조회합니다. 따라서 fetch join을 사용하지 않으면 N+1 쿼리가 돕니다

*1 :구조를 바꾸어서 해결하는 방법
1. 부모 엔티티에 FK 고려
2. OneToOne -> OneToMany, ManyToOne 관계로 변경
3. lazy로 설정했을 때, 복수건을 조회하면  N+1이 문제가 발생한다.



*2 :구조를 유지한채 해결하는 방법
최적화 방법: fetch join, batch_fetch_size 설정


*(예시 -> 해결순서를 적용해보면)
-------------------------------------------------------------
(*구조를 바꾼다.)
phone -> member로의 연관관계만 남겨두고 (구조를 유지하고)


(*2 최적화 1버전)
member를 조회할 때 fetch join으로 phone을 같이 조회한다.
toOne 관계이기 때문에 편하게 fetch join 할 수 있다. (-> 한방쿼리로 해결)

(*3 최적화 2버전)
hibernate.default_batch_fetch_size를 사용한다.
그러면 N+1을 1+1로 줄일 수 있다.
-------------------------------------------------------------
------------------------------------------------------------------------------------------------------------

